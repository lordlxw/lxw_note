# 操作系统（南大-Jyy老师）

## 一、并发

并不是所有的程序都是靠CPU执行

由于计算资源的计算，有了同时将多个程序载入内存的能力

> * 操作系统需要决定将哪些程序装入内存
> * 在多个隔离的程序之间切换                                                      =>引出中断和进程调度
> * 操作系统中多了“进程”对象和进程管理API

> Linux：vim、cat、xxd（反汇编）可以读取文件
>
> ELF文件——**可扩展链接格式**是linux系统上标准二进制文件。如果文件没有任何扩展名，我们将首先考虑elf文件
>
> Linux上调用程序：
>
> 用到的只是这么点Api
>
> 被操作系统加载：通过父进程得execve
>
> 不断执行系统调用：
>
> 进程管理：fork、execve、exit
>
> 文件/设备管理：open、close、read、write
>
> 存储管理：mmap、brk
>
> 直到：_exit(exit_groop)——退出

### 1、并发的概念



> ​	处理器数量			共享内存					典型并发系统								并发/并行
>
> | 单处理器 | 共享内存   | OS内核/多线程程序      | 并发不并行 |
> | :------- | ---------- | ---------------------- | ---------- |
> | 多处理器 | 共享内存   | OS内核/多线程/GPU      | 并发、并行 |
> | 多处理器 | 不共享内存 | 分布式系统（消息通信） | 并发、并行 |
>
> 并发：多个执行流不按照一个特定顺序执行
>
> 并行：允许多个执行流同时执行（==多处理器==）



### 2、线程

> 线程：共享内存和代码中全局数据，两个执行流共享代码和所有全局变量
>
> 线程之间执行的指令顺序是不确定的

> 线程：不共享寄存器和堆栈，每个线程独享寄存器和堆栈（rip、rsx、rax）

> 程序=有限状态机

### 3、皮特森算法——软件实现两个线程的互斥

> Peterson算法是一个实现[互斥锁](https://baike.baidu.com/item/互斥锁/841823)的并发程序设计算法，可以控制两个[线程](https://baike.baidu.com/item/线程/103101)访问一个共享的单用户资源而不发生访问冲突
>
> 两个进程：Pi 、 Pj
>
> 两个进程共享两个共享变量：in turn 	 bool flag[2]
>
> turn:指示哪个进程可以进入临界区
>
> flag:指示进程是否已准备好进入临界区
>
> 谦让行为：当Pi想进入临界区时，Pi的flag置为true，而trun=Pj。让Pj进程先走
>
> 现代计算机体系结构并不适用，因为当代CPU为了优化程序代码会乱序执行

> 代码：==Pi想进入临界区==
>
> ```C
> do{
>     
>     flag[i]=true;
>     turn=j;						//先给j权限，让他可以先有临界区的访问权限
>     while(flag[j]&&turn==[j]); //谦让，如果j准备好进，且也允许它进（turn=j），等待-死循环。。。
>     只有当j flag=false时，它退出循环，让I正式进入临界区
>     
>     ==临界区==
>         
>     flag[i]=false;  //当Pi完成临界区的操作后，flag[i]=false;可以让J进入临界区
>     
>     ==剩余部分==
>         
> }while(TRUE);
> }
> ```
>



### 4、线程的互斥

> 线程互斥：线程不想被别人打断地做一件事，一旦开始，其他人必须等待
>
> lock  &  unlock
>
> load（读）、store（写）——原子指令
>
> 一条add指令可以看成 三条：t=load(x),t++,store(x,t)

==软件不够，硬件来凑==

> 如果硬件能同时完成 test and set 操作，就可以解决互斥问题——保证原子性



X86系统中的原子操作：

> xchg——完成两个元素的交换



#### 4.1自旋锁-实现互斥

> 利用xchg拿到key
>
> 循环想拿到锁，直到拿到锁为止（但只有一个人能拿到）

