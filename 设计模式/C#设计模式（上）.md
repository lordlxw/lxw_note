# C#设计模式

https://www.bilibili.com/video/BV1QH4y1c78x/?spm_id_from=333.999.0.0&vd_source=f93c2f87ac116d0ab5a7d34711f601c7

==**基于C#10，.net 6**==



> 整体分为三种设计模式
>
> 设计模式通常被分类为三大类：
>
> 1. **创建型模式（Creational Patterns）**：
>    - 这些模式主要关注如何创建对象。它们通过提供不同的创建方式来提高系统的灵活性和可重用性。
>    - 例子包括：
>      - **单例模式（Singleton）**：确保一个类只有一个实例，并提供一个全局访问点。
>      - **工厂方法模式（Factory Method）**：定义一个创建对象的接口，但由子类决定实例化哪个类。
>      - **抽象工厂模式（Abstract Factory）**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体类。
>      - **建造者模式（Builder）**：使用多个简单的对象一步步构建成一个复杂的对象。
>      - **原型模式（Prototype）**：通过复制现有的实例来创建新的实例，而不是通过构造函数创建。
> 2. **结构型模式（Structural Patterns）**：
>    - 这些模式主要关注如何将类和对象组合成更大的结构，以便它们可以在不同的系统中协同工作。
>    - 例子包括：
>      - **适配器模式（Adapter）**：允许不兼容的接口之间进行合作。
>      - **装饰者模式（Decorator）**：动态地给一个对象添加一些额外的职责。
>      - **代理模式（Proxy）**：为另一个对象提供一个代理，以控制对该对象的访问。
>      - **外观模式（Facade）**：提供一个统一的接口来访问子系统中的一群接口。
>      - **桥接模式（Bridge）**：将抽象部分与实现部分分离，使它们可以独立变化。
>      - **组合模式（Composite）**：将对象组合成树形结构以表示“部分-整体”层次结构。
>      - **享元模式（Flyweight）**：通过共享大量细粒度的对象来节省内存。
> 3. **行为型模式（Behavioral Patterns）**：
>    - 这些模式主要关注对象之间的通信和职责分配。
>    - 例子包括：
>      - **观察者模式（Observer）**：定义一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
>      - **策略模式（Strategy）**：定义一系列算法，将每一个算法封装起来，并使它们可以互换。
>      - **状态模式（State）**：允许对象在内部状态改变时改变它的行为。
>      - **责任链模式（Chain of Responsibility）**：将请求沿着处理链传递，直到有一个对象处理它。
>      - **命令模式（Command）**：将请求封装为一个对象，从而使你能够使用不同的请求、队列请求和记录请求日志。
>      - **备忘录模式（Memento）**：在不暴露对象内部结构的情况下，捕捉对象的内部状态，并在以后恢复它。
>      - **解释器模式（Interpreter）**：给定一个语言，定义它的文法，并提供一个解释器来解释语言中的句子。
>      - **中介者模式（Mediator）**：定义一个中介对象来封装一组对象之间的交互，从而使这些对象不需要显式地相互引用。
>      - **迭代器模式（Iterator）**：提供一种方法来顺序访问集合对象中的元素，而无需暴露集合对象的内部表示。
>      - **模板方法模式（Template Method）**：在一个方法中定义算法的骨架，而将一些步骤延迟到子类中。
>      - **访问者模式（Visitor）**：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。



> Gang of four —— 四个人出的最权威的Design Patterns设计模式书（23个设计模式）
>
> 意图！！！
>
> 核心四问：
>
> 1、如何确保类仅有一个实例？
>
> 
>
> 2、如何使两个不同接口的对象协同工作？
>
> 
>
> 3、如何在不改变底层对象的情况下扩展对象接口？
>
> 
>
> 4、如何启用撤销功能？
>
> 
>
> 两个原则：
>
> 1、编程到接口，而不是实现
>
> 
>
> 2、对象组合优于类继承





## A-创建型模式



### 单例模式

> 单例模式的目的是确保类只有一个实例，提供一个全局入点。
>
> 例子：
>
> logger记录器
>
> 利用静态变量 / 容器 可以很简单的实现
>
> lzay实例化是个很好的实现
>
> 惰性原则，我们只创建一个类的实例，一旦我们需要它，而不是在它建造的时候，且dotnet确保它是线程安全的





> 相关设计模式
>
> 抽象工厂
>
> Builder
>
> Prototype
>
> State



### 工厂模式

> 将实例化推广至多个子类
>
>  
>
> 意图：
>
> 工厂模式的意图是定义创建对象的接口，但让子类决定实例化哪个类，工厂方法让类==推迟实例化==给子类。
>
> 
>
> 紧耦合---》松耦合
>
> ![image-20240728141535572](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20240728141535572.png)

> 使用情景：
>
> 一个折扣方法，可以根据国家打折，也可以根据折扣打折
>
> DiscountFactory就产生了。
>
> 
>
> 创建者声明工厂方法，必须返回一个产品实例。

> 与工厂模式相关的有：
>
> 1、抽象工厂
>
> 2、原型模式（偏爱组合而非继承）
>
> 3、模板方法





### *抽象工厂模式

> 意图：
>
> 抽象工厂意图是提供创建相关依赖对象的接口，却未置顶具体类
>
> 
>
> 核心：
>
> 返回接口而不是具体实现 
>
> 客户端与具体实现解耦
>
> 抽象工厂的实现被称为具体工厂



> 例子：
>
> 比利时一件商品：
>
> A、折扣率
>
> B、运费
>
> 
>
> 法国一件商品：
>
> A、折扣率
>
> B、运费
>
> 比利时有比利时的折扣规则和运费规则，法国有法国的折扣规则和运费规则。所以有 四个类产生。
>
> 分别是：
>
> 1、比利时折扣服务
>
> 2、法国折扣服务
>
> 3、比利时运费服务
>
> 4、法国运费服务
>
> 1、3加起来就是一个产品A，2和4加起来就是产品B



> 总结：
>
> 与类分离，避免紧耦合。
>
> 因此，可以轻松引入新产品而不会破坏客户端代码
>
> 创建产品在一个地方，遵循了单一职责原则。
>
> 
>
> 一个潜在缺点是支持新产品相当困难。
>
> ***如果想扩展抽象工厂，必须更改工厂接口，这也意味着更改所有子类的实现。



> 抽象工厂 和 工厂模式 的比较
>
> 工厂方法只生产一种产品
>
> 抽象工厂通过公开接口来创建对象，返回类型是抽象类的接口。生产一系列产品，通过组合而不是继承来做到这一点。





### 建造者模式

> 意图：
>
> 分离复杂对象的构建和表示，相同的构建过程可创建不同表示
>
> 
>
> 车由不同组件构成的，BMW是一种，Mini也是一种。



> 后果：
>
> 它允许我们控制产品的内部表示
>
> 接口让构建器隐藏了产品的表示和内部结构。使改变的产品变得容易，只需新建一种构建器。提高模块化。更细粒度控制构建过程。由一个director来全权管理。
>
> 
>
> 核心：两步
>
> 1、定义一个抽象基类或者接口作为构建器
>
> 2、让导演在构建器上工作，而不是具体构建器实现上。





### 原型模式

> 使用原型实例
>
> 
>
> 意图：
>
> 指定要创建的对象类型，通过复制这个原型来创建新的对象，换句话说，它允许我们复制现有的对象，而不会使客户端代码依赖于具体类。
>
> 
>
> 原型模式：
>
> 有一个基类，声明了一个克隆自己的接口。



#### 浅拷贝和深拷贝

> 浅拷贝——原始类型值的副本
>
> 深拷贝——可以修改原始对象，在不影响被克隆物体的情况下。
>
> MemberwiseClone —— 始终创建浅拷贝
>
> ### 深拷贝（Deep Copy）
>
> 深拷贝创建一个新对象，该对象是原始对象的精确副本，包括所有引用类型字段引用的对象。也就是说，深拷贝会递归地复制整个对象图，使得原始对象和拷贝对象完全独立。
>
> 
>
> ### 浅拷贝（Shallow Copy）
>
> 浅拷贝创建一个新对象，该对象是原始对象的精确副本，但对于引用类型字段，浅拷贝只复制它们的引用，而不是引用的对象本身。因此，原始对象和拷贝对象中的引用类型字段指向同一个对象。





## B-结构型模式

> 意图：
>
> 将一个类的接口转换为另一个接口（客户期望的）
>
> 所以适配器模式让不同接口的类可以一起工作（不兼容的接口一起）
>
> 
>
> 







### 适配器模式

#### 对象适配器

> ==两个不兼容==
>
> 通过适配器来使他们兼容
>
> 适用于对象组合



#### 类适配器

> 一种变体
>
> 依赖于多重继承来适配一个接口到另一个接口
>
> -- C#是一种偏爱组合的语言，不支持多重继承 --



> 缺点：引入额外的接口和类，相当于增加了复杂性
>
> 相关模式：
>
> Bridge：
>
> 桥接意味着将接口与其实现分开，可以容易地独立变化
>
> 
>
> Decorator：
>
> 装饰器在不更改对象接口地情况下更改对象，比适配器更透明
>
> 
>
> Facade：
>
> 定义新接口
>
> 
>
> Proxy：
>
> 为另一个对象定义代理，而不改变接口

---





### 桥接模式

>Bridge：
>
>将抽象与其实现解耦
>
>两者可以 ==独立改变==
>
>提供在不修改抽象地情况下用另一个实现替换一个实现的方法
>
>比如：
>
>Console.WriteLine就是一种抽象

> 很常见的一种设计模式
>
> 场景：
>
> 1、希望避免抽象与其实现之间永久绑定
>
> 2、桥接模式支持在运行时==支持切换==
>
> 3、支持独立扩展
>
> 
>
> 后果：
>
> 1、解耦
>
> 2、可扩展性改善
>
> 3、对客户端隐藏实现细节
>
> 
>
> 相关设计模式：
>
> 抽象工厂
>
> 适配器
>
> 策略模式
>
> 状态模式





### 装饰器

> 该模式允许动态添加行为到单个对象 不影响同一类其他实例的行为
>
> 有时称之为包装器
>
> 
>
> 目的是 动态地将额外的责任附加到对象身上。有点像适配器
>
> 
>
> 实际就是在不影响原来对象的基础上增加功能
>
> 
>
> 装饰器可以动态添加，也可以动态移除。
>
> 
>
> 这种模式倾向于比较小、简单的类



> 相关模式：
>
> 适配器模式
>
> 复合模式
>
> 策略模式





### 组合模式

> 常用于 ==树状数据结构==
>
> 比如文件系统-文件和目录
>
> 
>
> 意图：
>
> 旨在将对象组合成树形结构。表示部分整体层次，某个部分都是对象。
>
> 
>
> 优势：
>
> 可以让用户忽略对象组合与单个对象间的区别。
>
> 
>
> 后果：
>
> 客户端简单，调用透明
>
> 缺点：整个系统过于通用
>
> 
>
> 相关模式：
>
> 责任链模式
>
> 迭代器模式
>
> 访问者模式





### 外观模式

> Facade——很常用
>
> 意图：
>
> 在子系统上提供更高级别的接口，使子系统更容易使用
>
> 
>
> 外观模式提供统一接口
>
> 定义高层
>
> 比较简单
>
> 就是一个主类：
>
> 里面包含相关子类的实例对象
>
> 
>
> 优势：
>
> 当子类业务变复杂了
>
> Facade还是照常调用，没有影响
>
> 当客户机之间有许多==依赖关系==时，考虑这种模式很不错
>
> 
>
> 相关模式：
>
> 抽象工厂
>
> 中介模式
>
> 适配器模式





### 代理模式

> 意图：
>
> 为另一个对象提供代理项或占位符，以控制对它的访问
>
> 解决的问题是 ==访问控制==
>
> 
>
> 注意：与直接调用http api是不同的，其实就是加了一层
>
> 通过代理模式，客户端可以通过代理对象与实际对象进行交互，而代理对象可以在不改变客户端代码的前提下，增加对实际对象的控制和扩展功能。



> 代理模式有几种变体：
>
> **远程代理（Remote Proxy）**：为一个对象在不同地址空间提供局部代表。比如，访问远程服务器上的对象。
>
> **虚拟代理（Virtual Proxy）**：根据需要创建开销很大的对象，通过代理来控制对真实对象的访问。
>
> **保护代理（Protection Proxy）**：控制对原始对象的访问，提供不同权限的不同用户对对象的访问控制。
>
> **智能指引（Smart Reference）**：取代简单的指针，它在访问对象时执行一些附加操作。





> 使用场景
>
> 当你需要向实际对象添加某种形式的==访问控制==时
>
> 
>
> 相关模式：
>
> 适配器
>
> 装饰器







### 享元模式

> FlyWeight
>
> 通过共享来支持细粒度的对象
>
> 
>
> 意图：
>
> 共享，各有状态
>
> 比如 字母（有大小和颜色）
>
> 内在状态复用
>
> 

> 使用场景：
>
> 1、使用大量对象
>
> 2、对象量大存储成本高
>
> 3、大部分对象状态可外部化
>
> 4、若移除外部化，大量对象可替换为少量共享对象
>
> 5、应用无需对象标识



> 后果：
>
> 优点：
>
> 节省内存
>
> 
>
> 缺点：
>
> 模式复杂



> 相关模式：
>
> 1、状态模式
>
> 2、策略模式







## C-行为型模式

### 模板方法模式

> 意图：
>
> 在操作中定义骨架（最经常用的）

> 核心：
> 就是复用
>
> 留给子类实现其他方法 控制算法部分（子类部分可变）
>
> 即设为虚方法或抽象方法
>
> 将模板方法提取到父类
>
> 
>
> 负面后果：
>
> 模板方法不能更改它们调用方法的顺序，框架是固定的
>
> 
>
> 相关模式：
>
> 工厂模式
>
> 策略模式



### 策略模式

> 最常用的行为模式
>
> 封装每个算法，策略让算法独立
>
> 
>
> 策略声明了支持所有算法的接口



> 使用场景：
>
> 当多个相关类仅行为不同时，可以使用此模式
>
> 不同算法变体
>
> 一个类有许多行为
>
> 
>
> 后果：
>
> 策略模式提供对上下文进行子类化的替代方法
>
> 用组合取代继承
>
> 此模式会引入额外的复杂度



> 相关模式:
>
> Flyweight
>
> Bridge
>
> State
>
> Template
>
> 
>
> 通过方法参数注入具体策略的变化——是当今很常见的方法





### 命令模式

> 意图：
>
> 将请求封装为对象，从而参数化不同请求的客户。将请求变为独立对象。调用者常见是UI组件，接收者可以是任何类型
>
> 
>
> 其实就是按钮点击事件，UI开发中很常见
>
> 
>
> 用例：
>
> 当希望参数化对象，传递
>
> 支持撤销
>
> 存储重用
>
> 
>
> 后果：
>
> 解耦操作类
>
> 命令可以被操作和扩展
>
> 命令可以组合成组合命令
>
> 潜在的负面后果是转移请求到对象时的复杂性，要加一层
>
> 
>
> 
>
> 相关模式：
>
> Composite
>
> Memento
>
> Prototype





### 备忘录模式

> Memento
>
> 意图：
>
> 存储命令内部状态以支持撤销操作
>
> 意图：
>
> 捕捉一个外部化对象的内部状态，因此，以后可以在不违反封装的情况下将对象恢复到该状态。
>
> 
>
> 用的不太多
>
> 
>
> md好复杂啊，看不懂

> ## 优点
>
> - 提供一种撤销机制，可以将对象恢复到以前的状态。
> - 保持封装性，外部对象无法访问Originator的内部状态。
>
> ## 缺点
>
> - 如果Originator的状态很复杂，可能会占用大量内存。
> - 管理者需要知道何时保存和恢复状态，增加了复杂性。
>
> Memento模式适用于需要保存和恢复对象状态的场景，如文本编辑器、游戏中的进度保存等。





### 中介者模式

> Mediator
>
> 例子：聊天室，A和B通过聊天室来实现通信（律师和律师通信，会计和会计通信）
>
> 
>
> 意图：
>
> 定义一个对象——中介者，来和一堆对象进行交互
>
> 通过强制对象通过中介通信
>
> 这样，可以通过保持对象不直接引用彼此来促进松耦合，并允许独立变化。

#### 推荐的Nuget包——MediatR

> 流行的.net中介者实现模式 作者是AutoMapper的作者





> 用例场景：
>
> 一个对象难以定义
>
> 当一个对象引用要与多对象通信
>
> 当分散在多个类的行为可定制时
>
> 
>
> 后果：
>
> 1、限制子类化
>
> 2、松耦合
>
> 3、简化对象协议
>
> 4、可扩展
>
> 5、使调解人变得复杂
>
> 
>
> 相关模式：
>
> Facade
>
> Command
>
> Mediator
>
> Observer
>
> 





### 责任链模式

> 意图：
>
> 避免请求发送者和接收者耦合
>
> 通过给多个对象处理请求的机会
>
> 通过将接收对象链接并沿链传递请求来实现 
>
> 直到一个对象处理它
>
> 
>
> 比如==复杂的条件判断==就可以用这种设计模式
>
> 一个不行，就不行，中断了



> 常见用例场景：
>
> 当多个对象可能处理请求，并且处理程序事先不知道时
>
> 当你想向几个对象中的一个发出请求时但没有指定接收
>
> 当应该动态指定可以处理请求的对象集时
>
> 
>
> 后果：
>
> 每个类可以单一职责
>
> 增加了分配对象责任的灵活性，可以控制处理器执行顺序
>
> 缺点：请求没有明确的接收者
>
> 
>
> 相关模式：
>
> Composite
>
> Command
>
> Mediator
>
> Observer



### 观察者模式

> 就是订阅-发布
>
> 
>
> 意图：
>
> 定义对象之间的多对一依赖 以便当一个对象状态改变时 所有依赖都被通知并自动更新
>
> 是很常见的模式
>
> 一个变（会员过期、加入会员），都要通知到
>
> 
>
> 用例：
>
> 当一个对象的更改需要更改其他对象时 
>
> 在==微服务==体系很常见
>
> 动态删除和订阅观察者 
>
> 
>
> 后果：
>
> 主题和观察者可以独立变化
>
> 松耦合
>
> 导致级联通知
>
> 
>
> 相关模式：
>
> 责任链
>
> Command
>
> Mediator





### *状态模式

> 意图：
>
> 允许对象改变其行为当它的内部状态发生变化。
>
> 对象将更改其类
>
> 
>
> 举例：
>
> 银行账户:
>
> 正常、超支、金卡
>
> 正常亏损---》超支
>
> 超支存钱---》正常
>
> 正常存很多钱---》金卡
>
> 金卡取出了很多钱---》正常/超支
>
> 
>
> 用例场景：
>
> 当一个对象行为取决其状态时，且必须在==运行时==改变其行为
>
> 当对象处理大型条件开关（if/switch）
>
> 
>
> 后果：
>
> 固定编码原则---》单一原则
>
> 可以轻松添加新状态和转换，开闭原则
>
> 负面：
>
> 模式将行为分布在不同状态子类之间，类数增加，则会增加复杂度。
>
> 比如你添加了一个金卡状态 就会与正常状态相挂钩（存1000元变成金卡）
>
> 
>
> 相关状态：
>
> Flyweight
>
> Singleton
>
> Strategy
>
> Bridge



### 迭代器模式

> 很常见，就是遍历，我们通常用自带框架实现，而非自己实现
>
> 
>
> 意图：
>
> 提供一种按顺序访问聚合对象元素的方式，而不暴露其底层
>
> 
>
> 用例场景：
>
> 避免了对对象内部表示的意外访问和操纵
>
> 当处理复杂数据结构时，可以隐藏复杂性
>
> 避免代码重复
>
> 
>
> 后果：
>
> 迭代器简化了聚合结构的接口，遍历代码被切分，遵循单一责任
>
> 可以实现新类型的聚合对象，迭代器可以在同一集合上同时存在（正序排，倒序排）
>
> 
>
> 相关模式：
>
> Composite
>
> Memento
>
> Vistor



==设计模式（上）结束==

---

