# Windbg学习

> 官方文档



## 一、前提知识

### 符号文件

> 符号文件（Symbol Files）是一个数据信息文件，它包含了应用程序二进制文件（比如：EXE、DLL等）调试信息，专门用来作调试之用，最终生成的可执行文件在运行时并不需要这个符号文件，但你的程序中所有的变量信息都记录在这个文件中。所以调试应用程序时，这个文件是非常重要的。用 Visual C++ 和 WinDbg 调试程序时都要用到这个文件。　　在 Windows 系统中，符号文件以 .pdb 为扩展名，比如：每个 Windows 操作系统下有一个 GDI32.dll 文件，编译器在编译该 DLL 的时候会产生一个 GDI32.pdb 文件，一旦你拥有了这个 PDB 文件，那么便可以用它来调试并跟踪到 GDI32.dll 内部。该文件和二进制文件的编译版本密切相关，比如修改了 DLL 的输出函数，再编译该 DLL，那么原先的 PDB 文件就过时了，不能再用老的 PDB 文件来做调试工作,而必须使用最新的 PDB 文件版本。



### 符号

> ### 符号的主要内容包括：
>
> 1. **函数名**：
>
>    - 符号文件包含了函数的名称、地址和参数信息。这使得调试器可以将程序的内存地址映射到具体的函数名称，从而在堆栈跟踪（stack trace）中显示函数调用链。
>
>    例如：
>
>    ```
>    00007ffe`f60c2a50 notepad!CreateWindowExW
>    00007ffe`f60c2a80 notepad!CreateThread
>    ```
>
>    这些就是在 `notepad.exe` 模块中的函数符号，表示程序中某些功能的具体实现。
>
> 2. **变量名**：
>
>    - 符号文件还包含了程序中各个变量的名称和它们的内存地址。变量符号通常出现在全局变量、局部变量、静态变量等处。它们可以帮助你查看程序的状态，特别是调试时可以查看变量的值。
>
>    例如：
>
>    ```
>    notepad!g_hWnd
>    ```
>
>    这表示全局变量 `g_hWnd`，并且调试器可以在调试过程中显示该变量的值。
>
> 3. **类型定义（结构体、类）**：
>
>    - 符号文件还可以包含程序中使用的类型（如类、结构体、枚举等）的定义。这些定义使得调试器能够正确解析和显示复杂类型的数据。
>
>    例如：
>
>    ```
>    notepad!POINT
>    ```
>
>    这可能表示 `notepad.exe` 中的一个结构体类型 `POINT`，它定义了一个二维点的坐标（`x`, `y`）。
>
> 4. **DLL 和 EXE 模块**：
>
>    - 符号还包括加载的模块（DLL、EXE）中的符号信息。每当你调试一个程序时，调试器会尝试加载和解析程序依赖的库（如系统库、第三方库等）的符号信息，以便在调试时能够显示函数名、变量名等。
>    - 这些符号可以包括标准库（如 `kernel32.dll`）中的函数、你自己编写的 DLL 文件中的函数等等。
>
> 5. **源文件信息**：
>
>    - 如果符号文件（PDB 文件）包含源代码信息，它还可以帮助调试器将程序的内存地址与源代码行号相关联。这样，当程序崩溃时，调试器可以显示崩溃发生的源代码行，而不仅仅是内存地址。
>    - 这对调试有极大的帮助，因为它能直接指向问题的源代码行，而不是让你依赖于汇编代码。



## 二、命令

> ==.sympath srv*==
>
> 这个命令用于指定符号文件的存储位置，尤其是从 Microsoft 的符号服务器下载符号文件。
>
> **srv** 表示从符号服务器（如 Microsoft 的符号服务器）获取符号文件，后面跟着一个路径，指示存储符号文件的位置。如果符号文件没有在本地缓存中，WinDbg 会自动从指定的符号服务器下载它们。



> ==.reload==
>
> 会重新加载所有当前调试会话中已加载的模块和符号。
>
> .reload /f
>
> 若没有输出，则强制刷新一下





> ==x notepad!*==
>
> ### 命令解释：
>
> - `x` 是 WinDbg 中用于**列出符号**的命令。它会显示与给定的模块或符号名称匹配的所有符号信息。
> - `notepad!*` 是你提供的符号名称模式，表示所有与 `notepad` 模块相关的符号。
>
> 这个命令会列出 `notepad.exe` 中的所有符号（函数、变量等）。如果你调试的是记事本程序或想要分析其内部函数或全局变量，这个命令很有用。



> ==x notepad!wWin*==
>
> 列出与 `notepad` 模块（`notepad.exe`）中名称以 `wWin` 开头的所有符号。
>
> `wWinMain` 是函数名，表示程序的入口点之一，通常是 Windows GUI 应用程序的入口函数（类似于 `main` 函数，但它用于 Windows 程序）。



























### 核心命令

> ==lm==
>
> 用于列出当前调试会话中已加载的模块（例如，`EXE` 或 `DLL` 文件）。它是 `List Modules` 的缩写，能够帮助你查看程序中加载了哪些模块以及它们的相关信息，比如模块的基地址、大小、符号信息等。
>
> 
>
> lm m notepad——会列出名为 `notepad` 的模块的详细信息
>
> lm v——显示模块的版本信息。
>
> lm v mymodule.dll——显示名为 `mymodule.dll` 的模块的详细信息，包括版本号和其他元数据。
>
> 
>
> 如果某个模块没有正确加载符号，使用 `lm` 可以帮助你确认模块是否存在符号加载问题（例如，显示 `deferred` 表示符号没有加载）。



#### 断点调试

> ==bu==
>
> bu notepad!wWinMain
>
> `bu` 命令用于设置一个 **未处理异常断点**（Unhandled Exception Breakpoint）。这意味着，当程序抛出某种异常而没有被处理时，调试器会自动暂停执行。
>
> 意味着调试器只会在程序发生未处理的异常时打断点。



> ==bl==
>
> 用于列出当前所有的断点
>
> ```CMD
> 0 e Disable Clear  00007ff7`3dbe0108     0001 (0001)  0:**** notepad!wWinMain
> ```
>
> **`0`**：表示断点的编号。每个断点都有一个唯一的编号，`0` 表示这是第一个断点。
>
> **`e`**：表示该断点的状态是 **"启用"**（Enabled）。如果你看到 `e`，表示这个断点当前是启用的，可以在程序执行时触发。其他可能的状态还包括 `d`（禁用）和 `u`（未启用）。
>
> **`Disable`**：这个字段表示断点的操作状态。`Disable` 表示该断点被禁用了，通常是手动禁用的，可以通过 `bd` 命令将其禁用。看起来这里你看到的 `Disable` 是在显示的过程中有些冲突，实际上是禁用状态，但命令列表仍然显示它是 "e" 状态（启用）。
>
> **`Clear`**：表示这个断点是已被清除的，断点已经被移除，但在 `bl` 输出中显示清除。
>
> **`00007ff7`3dbe0108**：这是断点的内存地址。这个地址表示的是 `notepad.exe` 中 `wWinMain` 函数的入口地址。也就是说，当程序运行到这个地址时，断点会被触发。
>
> **`0001 (0001)`**：这通常是有关该断点的其他信息，具体来说，表示该断点被设置为在函数执行时触发。
>
> **`0:\**\**`**：表示该断点所在的线程。这里 `0:****` 表示断点在主线程或一个特定的线程。





> ==g==
>
> `g` 命令是 **"Go"** 命令的缩写.主要用于 **继续程序的执行**，直到下一个断点、异常或程序结束。
>
> ### 相关命令：
>
> - **`p`**：单步执行，跳过当前函数（逐行执行代码）。
> - **`t`**：单步执行，进入当前函数（逐步跟踪）。
> - **`s`**：继续执行，直到下一个源代码行（类似 `g`，但是源代码级别的）。





> ==k==
>
> `k` 命令用于 **查看调用堆栈**（call stack）。调用堆栈是程序执行时函数调用的记录，它显示了当前线程在执行到某个位置时所经历的所有函数调用路径。







#### 线程追踪

> ==~==
>
> 列出所有线程的信息，包括线程ID、状态和优先级。
>
> 
>
> ~0s
>
> k
>
> 查看线程0的堆栈追踪







#### 终止调试

> ==qd==
>
> 用于 **卸载符号**，并从符号缓存中移除特定的符号文件。具体来说，`qd` 命令会卸载指定的符号模块，清除相关的符号信息。