链接：

https://www.youtube.com/watch?v=BKynEBPqiIM&list=PLQMqUlV2_B8lC_MlZg-sMitFaA5-QJ0e4

# C# 面试问题



## Part I （C#30问）

>==Q1==：C# 和 .net 区别
>
>A：
>
>.net 是框架，C#是语言。
>
>C#有语法、文法、源代码
>
>.net 有 CLR、库的集合 和运行时、GC
>
>.net能帮我们编译运行程序
>
>

> ==Q2== framework & core 区别
>
> A：
>
> .net 5以上提供了一种统一（将.net framework 和 .net core 3.X整合）
>
> .netCore性能要优于.net framework。因为.net framwork里引用的dll都很大，.net core里拆分成了小块，用时内存占用更少。
>
> `NET Core` 及更高版本（如 .NET 5/6/7/8）使用 `dotnet build` 进行构建。
>
> .NET Framework` 应用程序使用 MSBuild 或 Visual Studio 来构建，不支持 `dotnet build`。
>
> .net Core中可以用CLI，但是framework不行。用命令行的优势就是可以与任何IDE集成，快速绘制模板。





> ==Q3==:什么是IL Code?
>
> A：C#程序要被运行，必须要被编译成汇编。C#不会直接转成机器语言，而是转成中间语言IL





> ==Q4==:JIT有什么用？
>
> A：JIT——即时编译器，运行IL代码并将其编译为机器语言。



> ==Q5==：能直接看到IL代码吗？
>
> A：用ILDSM 或 ILSPY等反编译工具就可以直观看到IL代码了。



> ==Q6==：编译成IL代码有啥好处呢？？或者说为什么要加一层？
>
> A：因为开发环境和运行环境的差异。IL可以负责统一整合。
>
> 假设开发人员用win10 64位
>
> 但运行时环境可以是win8、XP



> ==Q7==:.Net支持多种语言么？
>
> A：VB、F#、C#、C++



> ==Q8==:CLR的重要性？
>
> A：CLR代表公共语言运行时，它是.net运行时环境
>
> CLR主要做两件事：
>
> ①、将IL语言转为本机语言
>
> ②、运行程序时的GC，CLR负责垃圾回收





> ==Q9==:托管代码和非托管代码有啥区别？
>
> A：在CLR环境下执行的代码称为管理代码
>
> DllImport就是非托管代码。
>
> **托管代码**：内存管理由 **.NET 公共语言运行库 (CLR)** 自动处理。CLR 会通过垃圾回收（GC, Garbage Collection）机制自动分配和释放内存，程序员不需要手动管理内存。这降低了内存泄漏和悬挂指针等错误的风险。
>
> - 例如：C#、VB.NET 等 .NET 语言编写的代码是托管代码。
>
> **非托管代码**：内存管理完全由程序员手动控制，程序员需要显式地分配和释放内存。开发者需要使用诸如 `malloc`、`free`（C/C++）等手段来管理内存，这容易引发内存泄漏、越界访问等问题。
>
> - 例如：C、C++ 编写的代码通常是非托管代码。



> ==Q10==:GC的重要性？
>
> A：
>
> 垃圾收集器是一个连续运行的后台进程，并占用任何类型的未使用的托管资源。
>
> 针对托管资源，GC会时不时出现并开始清理。





> ==Q11==:GC可以声明非托管对象吗？
>
> A：
>
> 答案是否定的。GC无法收集在CLR之外创建的对象。



> ==Q12==:解释一下CTS的重要性？
>
> A：
>
> CTS代表通用类型系统。
>
> ![image-20241215150753478](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20241215150753478.png)
>
> **CTS** 是 .NET 平台中的一个核心概念，它定义了所有类型的统一标准，确保了不同编程语言之间的互操作性。
>
> 值类型 与 引用类型



> ==Q13==:CLS是啥？
>
> A：CLS代表公共语言规范。C#区分大小写
>
> **CLS**（Common Language Specification）则定义了一个子集，描述了 .NET 环境中所有语言必须遵守的规则。CLS 主要关注如何让不同语言之间的互操作更顺畅，而 CTS 关注如何定义类型系统。



> ==Q14==：堆和栈的区别？
>
> A：两种内存类型。
>
> 在栈上分配的是：整数、bool、double、decimal
>
> 变量和值存储在同一位置。
>
> 
>
> 堆上分配对象
>
> 创建对象时这个对象在栈上分配，但值将存储在堆中。
>
> **引用类型**（如 `class`、`array`、`delegate`）的对象本身是存储在 **堆** 上的，但对象的引用（指针）存储在栈中。也就是说，**栈上存储的是对象的引用地址，而堆上存储的是对象的数据（即实际内容）**





> ==Q15==：什么是值类型和引用类型？
>
> A：
>
> 值类型是存储在栈上的类型、值和指针存储在同一位置。
>
> 引用类型是指**对象的引用** 存储在栈上，而 **对象的数据** 存储在堆中。”





> ==Q16==:什么是拆箱和装箱？
>
> A：
>
> 装箱——数据从值类型---》引用类型
>
> 拆箱——数据从引用类型---》值类型



> ==Q17==：拆箱和装箱后果是什么？
>
> A：
>
> 就是性能。堆栈不停转换



> ==Q18==:类型转换，隐式类型转换和显示类型转换
>
> A：总结
>
> | **转换类型**          | **关键字/方法**            | **特点**                              |
> | --------------------- | -------------------------- | ------------------------------------- |
> | 隐式转换              | 自动                       | 不需要强制转换，安全无异常            |
> | 显式转换              | `(类型)`                   | 需要强制转换，可能丢失数据            |
> | `as` 转换             | `as`                       | 失败返回 null，不抛异常               |
> | `is` 类型检查         | `is`                       | 检查类型，结合模式匹配                |
> | `Convert` 类          | `Convert.ToXXX()`          | 基本数据类型转换，失败抛异常          |
> | `Parse` 和 `TryParse` | `int.Parse()`/`TryParse()` | 字符串转换为数值，`TryParse` 不抛异常 |
> | 自定义转换            | `implicit` / `explicit`    | 运算符重载，定义类型转换              |
> | 动态类型              | `dynamic`                  | 运行时确定类型                        |
>
> 根据实际需求选择合适的转换方式，避免不必要的异常或性能问题。
>
> 小类型转大类型就是隐式 int 转 double
>
> 大转小需要显式 double 转 int



> ==Q19==:显式转换的后果是什么？
>
> A：
>
> 显示的缺点是会造成数据丢失



> ==Q20==：Array 和 ArrayList 区别是什么？
>
> ==Q21==：谁的性能更好呢？
>
> A：
>
> ## 总结对比表
>
> | **区别点** | **Array**                | **ArrayList**                      |
> | ---------- | ------------------------ | ---------------------------------- |
> | 类型安全   | 是（固定类型）           | 否（非类型安全，存储 object 类型） |
> | 性能       | 高（无装箱拆箱）         | 较低（值类型需要装箱和拆箱）       |
> | 长度/容量  | 固定                     | 动态调整容量                       |
> | 命名空间   | `System`                 | `System.Collections`               |
> | 替代方案   | 无替代                   | `List<T>`（泛型集合）              |
> | 使用场景   | 类型安全、固定大小的情况 | 旧版本代码、不关心类型安全的情况   |



> ==Q22==：什么是generic collections？
>
> A：
>
> 泛型集合，吸收了array和arraylist的优点
>
> 既是强类型（不涉及拆装箱）
>
> 又灵活，最常用的类型



> ==Q23==：什么是多线程？
>
> A：
>
> C#中多线程可以多线程执行方法。



> ==Q24==：Thread & Task（TPL -Task Parallel Library）区别是什么
>
> A：Task是4.X提出的
>
> ### 总结：
>
> | 特性           | **Thread**                                   | **TPL（任务并行库）**                               |
> | -------------- | -------------------------------------------- | --------------------------------------------------- |
> | **创建和管理** | 需要手动创建和管理线程                       | 使用线程池自动管理任务                              |
> | **性能**       | 线程创建和销毁开销较大，频繁切换时效率低下   | 线程池复用线程，减少创建销毁的开销，提高性能        |
> | **易用性**     | 编程复杂，需要手动管理线程的同步、通信等问题 | 提供简化的API，易于使用，开发者关注任务而非线程管理 |
> | **调度**       | 线程的调度由操作系统管理                     | 任务自动调度到合适的线程池线程，提高执行效率        |
> | **适用场景**   | 精细控制线程，如底层操作或长期运行的线程     | 高效并行处理任务，如数据处理、大规模并行计算等      |
>
> Thread似乎不太智能，不会进行核心的调度
>
> 而Task利用了处理器(processors)，CPU具有亲和性（Affinity），无需构建多余代码
>
>  Task可以返回结果，但Thread不行。
>
> 为了从线程中获取结果，需要使用委托、事件等。
>
> 而Task可以捕获任务、改变任务、等待其余任务完成，可以使用异步。
>
> 总之——TPL是一个超越Thread的抽象。
>
> 用新不用旧！





> ==Q25==：C#中如何处理异常？
>
> A：
>
> try-catch
>
> 
>
> ==Q26==:finally的作用？
>
> A：
>
> 编写额外代码，无论是否有异常都会执行。



> ==Q27==：out关键字什么时候用？
>
> A：
>
> 方法默认只返回1个类型，若要额外返回多个值，就可以用out。

---



Q28 —— Q30 重要的三个问题

> ==Q28==:委托必要么？
>
> A：
>
> Delegate是一个指向函数的指针，当谈论线程间通信十分游泳。它是一个回调。
>
> 
>
> ==Q29==:什么是event？
>
> A：
>
> event是委托的包装器，只能+=，-=而不能=（能用=是因为.net做了部分开放），订阅发布模型。
>
> 
>
> ==Q30==：抽象类和接口的区别是什么？
>
> A：
>
> 抽象类是半定义的父类，共性提取可以使用抽象类
>
> 而接口是一个合约。接口强制将结构纳入类中。
>
> 
>
> ### **总结：**
>
> | 特性           | **抽象类（abstract class）**                          | **接口（interface）**                      |
> | -------------- | ----------------------------------------------------- | ------------------------------------------ |
> | **定义**       | 使用 `abstract class` 定义                            | 使用 `interface` 定义                      |
> | **成员实现**   | 可以包含方法实现，或仅声明抽象方法                    | 只能声明方法、属性等，不能提供方法实现     |
> | **继承/实现**  | 支持类的单继承，支持接口的实现                        | 支持类的多重实现，不能继承类，只能继承接口 |
> | **字段**       | 可以包含字段                                          | 不能包含字段                               |
> | **构造函数**   | 可以定义构造函数                                      | 不能定义构造函数                           |
> | **访问修饰符** | 支持访问修饰符（如 `public`、`private`、`protected`） | 成员默认 `public`，不能有其他访问修饰符    |
> | **多重继承**   | 不支持多重继承                                        | 支持多重接口实现                           |
> | **用途**       | 用于表示共享实现的类族                                | 用于表示多个类可以共享的行为规范           |
>
> ### **选择使用抽象类还是接口：**
>
> - **使用抽象类**：当你希望为一组类提供一些共同的实现，或者当你希望通过继承提供部分实现时，可以使用抽象类。
> - **使用接口**：当你需要定义不相关的类之间共享某种行为时，或者当你希望支持多重继承时，可以使用接口。





## Part II(额外oop的概念)

>==Q1==:为什么需要OOP？
>
>A：
>
>从现实世界的对象的角度思考，更好地组织代码，聚合。
>
>以及实用性。
>
>
>
>==Q2==:OOP的四个支柱是什么？
>
>A：
>
>①、抽象——只显示必要的东西
>
>②、多态
>
>③、继承
>
>④、封装——隐藏复杂性



> ==Q3==：类 和 对象 什么？
>
> A：
>
> 类是蓝图
>
> 而对象是具体实例
>
> 
>
> ==Q4==：区分抽象和封装
>
> A：抽象意味着只显示必要的内容
>
> 封装意味着隐藏复杂性。
>
> 抽象发生在设计阶段
>
> 而封装发生在实现阶段，用private、public来实现一系列功能，即封装实现抽象。



> ==Q5==：继承
>
> A：
>
> 子类获得父类方法的所有属性，也可以在子类中扩展



> ==Q6==：virtual关键字是什么？
>
> ==Q7==：override是什么？
>
> A：`virtual`关键字主要用于**方法**、**属性**或**事件**的声明，表示它们可以在**派生类**中被**重写**（override）。其作用是实现**多态性**，提供一种在基类和派生类之间定义和扩展功能的机制。
>
> 
>
> 
>
> ==Q8==：overloading和overrriding一样吗？
>
> ==Q9==：解释一下重载？
>
> A：
>
> ### **主要区别总结**
>
> | **特性**         | **方法重载（Overloading）** | **方法重写（Overriding）**                                  |
> | ---------------- | --------------------------- | ----------------------------------------------------------- |
> | **发生位置**     | 同一个类中                  | 基类与派生类之间                                            |
> | **是否依赖继承** | 不依赖继承                  | 依赖继承关系                                                |
> | **方法名称**     | 必须相同                    | 必须相同                                                    |
> | **参数列表**     | 必须不同（个数或类型不同）  | 必须相同                                                    |
> | **访问修饰符**   | 无要求                      | 基类方法需为 `virtual` 或 `abstract`，子类需使用 `override` |
> | **返回类型**     | 可以不同                    | 必须相同                                                    |
> | **多态性**       | 不支持运行时多态            | 支持运行时多态                                              |







> Q10-Q14 是关于多态的
>
> ==Q10==：什么是多态？
>
> ==Q11==：多态可以脱离继承吗？
>
> A：即 不同条件下采取不同行动的能力。
>
> 要实现多态，必须继承。
>
> 
>
> 
>
> ==Q12==：static 和 dynamic 
>
> A：运行时多态和编译性多态。 
>
> 静态多态通过 重载实现
>
> 动态多态通过 覆盖实现
>
> 
>
> 
>
> ==Q13==：运算符重载是什么？
>
> ==Q14==：如何实现一个自定义运算符重载？
>
> A：
>
> ```C#
> using System;
> 
> struct Point
> {
>     public int X { get; set; }
>     public int Y { get; set; }
> 
>     public Point(int x, int y)
>     {
>         X = x;
>         Y = y;
>     }
> 
>     // 重载 + 运算符
>     public static Point operator +(Point p1, Point p2)
>     {
>         return new Point(p1.X + p2.X, p1.Y + p2.Y);
>     }
> 
>     // 重载 - 运算符
>     public static Point operator -(Point p1, Point p2)
>     {
>         return new Point(p1.X - p2.X, p1.Y - p2.Y);
>     }
> 
>     public override string ToString() => $"({X}, {Y})";
> }
> 
> class Program
> {
>     static void Main()
>     {
>         Point p1 = new Point(2, 3);
>         Point p2 = new Point(4, 5);
> 
>         Point sum = p1 + p2; // 调用 + 运算符重载
>         Point diff = p1 - p2; // 调用 - 运算符重载
> 
>         Console.WriteLine($"p1 + p2 = {sum}");  // 输出: p1 + p2 = (6, 8)
>         Console.WriteLine($"p1 - p2 = {diff}"); // 输出: p1 - p2 = (-2, -2)
>     }
> }
> 
> ```
>
> 





> Q15——Q27 关于抽象类和接口的
>
> ==Q15==：为什么需要抽象类？什么是抽象类
>
> A：抽象类和接口相比，抽象类简单。
>
> 抽象类是一个半定义的父类，公共提取
>
> 
>
> 
>
> ==Q16==：virtual 关键字 和 abstract 关键字一样吗？
>
> A： **区别总结**
>
> | **区别**     | **`virtual` 关键字**             | **`abstract` 关键字**                  |
> | ------------ | -------------------------------- | -------------------------------------- |
> | **定义位置** | 可以在普通类或抽象类中使用       | 只能在**抽象类**中使用                 |
> | **方法实现** | 有**默认实现**                   | **没有实现**，方法体为空               |
> | **子类重写** | 子类可以选择**重写**或不重写     | 子类**必须重写**（除非子类也是抽象类） |
> | **强制性**   | 重写是可选的                     | 重写是强制的                           |
> | **示例作用** | 提供可选的重写机制（有默认行为） | 提供强制的重写机制（没有默认行为）     |
>
> ==Q17==：抽象类和普通类区别
>
> A：
>
> **抽象类**
> 使用 `abstract` 关键字修饰的类，表示该类是**不完整的**，==不能直接实例化==，通常作为基类，供派生类继承和实现。
>
> **普通类**
> 没有使用 `abstract` 修饰的类，表示该类是**完整的**，可以直接实例化。
>
> ==Q18==：是否能创建抽象类的实例？
>
> A：绝对不行
>
> ==Q19==：是否必须在子类中实现抽象方法？
>
> A：是的，强制性！因为子类中根本没有实现。
>
> **必须实现抽象方法**：派生类如果不是抽象类，必须实现抽象方法。
>
> 如果派生类是抽象类，它可以选择不实现抽象方法，直到派生类提供实现。
>
> ==Q20==：为什么简单基类/父类 不能取代抽象类？
>
> A：**抽象类** 通过**强制子类实现方法**、**部分实现**以及**不能实例化**等特性，确保了设计的规范性和一致性。
>
> **简单基类** 只是提供一些可重用的代码，没有强制要求子类遵守统一的接口，因此不能取代抽象类在**强制实现行为**和**设计约束**方面的作用。
>
> 有些事必须要交给子类啊
>
> 
>
> 
>
> ==Q21==：解释一下接口并叙述接口的好处？
>
> A：接口是一个契约！
>
> 强制实现，接口不能实现逻辑。也没有private、public
>
> 所有的都是public，联系紧密。
>
> 一个改，不得不改（have to）
>
> 
>
> 
>
> ==Q24==：多重继承？ 接口继承接口？
>
> A:
>
> ## **接口继承接口的特点**
>
> 1. **多继承**：接口支持多继承，一个接口可以继承多个其他接口。
> 2. **成员合并**：继承的接口成员会合并到派生接口中，但不能有具体的实现。
> 3. **类实现**：实现派生接口的类，必须实现所有继承链中定义的成员。
> 4. **无实现**：接口中的成员不能有具体实现，直到类实现接口时才提供具体逻辑。
>
> ==Q26==：接口隔离原则？
>
> A：
>
> ## **接口隔离原则的含义**
>
> 在C#中，接口的设计应该遵循**高内聚、低耦合**的思想，确保每个接口只包含客户端需要的特定功能。
>
> - **大而臃肿的接口** 会导致实现类被迫实现很多不需要的方法。
> - **接口隔离原则** 建议将大接口拆分为更小、更加具体的接口，让每个接口只负责一组相对独立的功能。
>
> //SOLID原则//
>
> ==Q27==：是否能创建接口实例呢？
>
> A：在C#中，**接口本身是不能被实例化的**。接口是一种**抽象类型**，它只定义了行为的规范（方法、属性、事件等），没有具体的实现。因此，你不能直接创建接口的实例。
>
> ==Q28==：抽象类之间可以多重继承抽象类吗？
>
> A：当然是否定的。
>
> 
>
> ==Q29==：最复杂的一个问题：
>
> 抽象类和接口的区别：
>
> 面试回答：
>
> 精简：
>
> 当抽象类中的方法都是抽象方法的时候其实和接口一样了。
>
> 



# 实际面试问题

> 涟元科技（许左）
>
> 1、值类型和引用类型区别
>
> 2、依赖注入是什么？如何在依赖注入里实现LRU服务？
>
> 答：1. **依赖注入（Dependency Injection, DI）** 1. **依赖注入（Dependency Injection， DI）**
>
> - **定义**：
>   - 依赖注入是一种设计模式，用于实现控制反转（IoC），将对象的创建和依赖关系的管理交给外部容器（如 DI 容器）来处理。
>   - 通过构造函数、属性或方法注入依赖对象，而不是在类内部直接创建依赖。
> - **优点**：
>   - 提高代码的可测试性和可维护性。
>   - 降低类之间的耦合度。
>   - 便于管理和配置依赖关系。
> - **应用场景**：
>   - 在 ASP.NET Core 中，依赖注入是核心特性，用于注入服务（如数据库上下文、日志服务等）。
>   - 在大型应用程序中，用于管理复杂的依赖关系。
>
> ------
>
> ### 2. **LRU（Least Recently Used）** 2. **LRU（最近最少使用）**
>
> - **定义**：
>
>   - LRU 是一种缓存淘汰策略，用于在缓存空间不足时，移除最近最少使用的数据。
>   - 它基于时间局部性原理，认为最近被访问的数据在未来更有可能被再次访问。
>
> - **实现方式**：
>
>   - 通常使用双向链表和哈希表结合实现，以保证 O(1) 的时间复杂度。
>
> - **应用场景**：
>
>   - 缓存系统（如 Redis、Memcached）。
>   - 页面置换算法（如操作系统中的虚拟内存管理）。
>   - 资源池管理（如数据库连接池）。
>
>   ### **应用场景示例**
>
>   - **场景描述**：
>     - 一个 Web 应用需要频繁查询用户信息，但用户信息在一定时间内不会变化。
>     - 为了提高性能，可以使用 LRU 缓存来缓存用户信息，并通过依赖注入将缓存服务注入到需要的地方。
>   - **实现步骤**：
>     1. 定义一个 LRU 缓存服务。
>     2. 在 DI 容器中注册该服务。
>     3. 在需要缓存的地方注入该服务。
>
>   ```C#
>   using System;
>   using System.Collections.Generic;
>   using Microsoft.Extensions.DependencyInjection;
>         
>   // 定义 LRU 缓存服务
>   public class LruCache<TKey, TValue>
>   {
>       private readonly int _capacity;
>       private readonly Dictionary<TKey, LinkedListNode<(TKey Key, TValue Value)>> _cache;
>       private readonly LinkedList<(TKey Key, TValue Value)> _list;
>         
>       public LruCache(int capacity)
>       {
>           _capacity = capacity;
>           _cache = new Dictionary<TKey, LinkedListNode<(TKey Key, TValue Value)>>(capacity);
>           _list = new LinkedList<(TKey Key, TValue Value)>();
>       }
>         
>       public TValue Get(TKey key)
>       {
>           if (_cache.TryGetValue(key, out var node))
>           {
>               _list.Remove(node);
>               _list.AddFirst(node);
>               return node.Value.Value;
>           }
>           return default;
>       }
>         
>       public void Put(TKey key, TValue value)
>       {
>           if (_cache.TryGetValue(key, out var node))
>           {
>               _list.Remove(node);
>               node.Value = (key, value);
>           }
>           else
>           {
>               if (_cache.Count >= _capacity)
>               {
>                   var lastNode = _list.Last;
>                   _cache.Remove(lastNode.Value.Key);
>                   _list.RemoveLast();
>               }
>               node = new LinkedListNode<(TKey Key, TValue Value)>((key, value));
>               _cache[key] = node;
>           }
>           _list.AddFirst(node);
>       }
>   }
>         
>   // 注册 LRU 缓存服务
>   public static class ServiceCollectionExtensions
>   {
>       public static IServiceCollection AddLruCache<TKey, TValue>(this IServiceCollection services, int capacity)
>       {
>           services.AddSingleton<LruCache<TKey, TValue>>(new LruCache<TKey, TValue>(capacity));
>           return services;
>       }
>   }
>         
>   // 使用 LRU 缓存服务
>   public class UserService
>   {
>       private readonly LruCache<int, string> _cache;
>         
>       public UserService(LruCache<int, string> cache)
>       {
>           _cache = cache;
>       }
>         
>       public string GetUserName(int userId)
>       {
>           var userName = _cache.Get(userId);
>           if (userName == null)
>           {
>               // 模拟从数据库获取用户信息
>               userName = $"User{userId}";
>               _cache.Put(userId, userName);
>           }
>           return userName;
>       }
>   }
>         
>   // 主程序
>   class Program
>   {
>       static void Main(string[] args)
>       {
>           var services = new ServiceCollection();
>           services.AddLruCache<int, string>(capacity: 100); // 注册 LRU 缓存服务
>           services.AddTransient<UserService>(); // 注册用户服务
>         
>           var serviceProvider = services.BuildServiceProvider();
>           var userService = serviceProvider.GetRequiredService<UserService>();
>         
>           // 使用缓存
>           Console.WriteLine(userService.GetUserName(1)); // 第一次从数据库获取
>           Console.WriteLine(userService.GetUserName(1)); // 第二次从缓存获取
>       }
>   }
>   ```
>
>   
>
> 
>
> 
>
> 
>
> 3、async/await是什么，什么情况下会用和普通Thread有什么区别？







> 波士顿科学（波科电话面试）
>
> md太恐怖了，问了不下20个问题。
>
> 1、如何实现浅拷贝和深拷贝呢
>
> 2、如何自定义一个线程池，可以设置线程的优先级
>
> 3、ManualResetEvent vs. AutoResetEvent 区别
>
> 4、如何实现一个事件总线eventbus？
>
> 5、C#里发生内存泄漏的场景有哪些？举点例子
>
> 6、如何让一个图片转为数据流的形式存储到文件
>
> 7、混淆加密软件有什么方法
>
> 8、如何实现一个单例，还要能实现延迟加载？
>
> 9、WPF性能怎么优化呢？
>
> 10、WPF中如何实现一个树形结构
>
> 11、如何实现序列化？
>
> 12、可空类型是什么？
>
> 13、如何实现多语言
>
> 14、如何完成.netframework到.netcore程序的迁移
>
> 15、.net core 和 .net framework 的区别
>
> 16、websocket 发送方如何降低延时
>
> 17、array.copy和clone的区别
>
> 18、如何实现一个内存数据库 增删改查
>
> 19、实现线程间的通信，其实就是问线程同步
>
> 20、static方法里能用this嘛
>
> 21、readonly 和 const的区别
>
> 
>
> 线下面试：
>
> md太远了。。。骑了40多分钟，屁股疼
>
> 我的笔试算法能力太差了，哎
>
> 
>
> 1、程序运行过程中，发生异常了，但没有写try...catch，应该怎么做呢？如何捕获这个异常？
>
> ```cmd
> 在 App 类的构造函数中，订阅 DispatcherUnhandledException 事件，用于捕获所有UI线程上的未处理异常。
> 你也可以处理 AppDomain.CurrentDomain.UnhandledException 事件，用于捕获非UI线程上的异常。
> ```
>
> 
>
> 2、try...catch...finally，在try中return了会调用finally吗？
>
> 3、C#中对象dispose有几个阶段，分别做了什么？
>
> 4、wpf中如何把一个控件对象转为bitmap



## 索雷博

>外企面试的问题，基本忘了。。。2025/06/09（周一）
>
>还是GG了，前两个还行，问了点C#和C++的问题。
>
>第一个问题：
>
>问string a = null; 和 string a = string.Empty有什么区别。
>
>我答的不是很好。。。基本区别
>
>| 方面          | `string a = null;`                        | `string a = string.Empty;`               |
>| ------------- | ----------------------------------------- | ---------------------------------------- |
>| 实际内容      | `a` 变量是**空引用**                      | `a` 是一个指向空字符串的实例（长度为 0） |
>| 是否分配内存  | ❌ 无任何对象分配                          | ✅ 有一个静态的 `""` 对象引用             |
>| 使用风险      | ⚠️ 直接访问会导致 `NullReferenceException` | ✅ 安全，任何 string 操作都是合法的       |
>| 是否等于 `""` | ❌ 否（`null != ""`）                      | ✅ 是                                     |
>| 适用场景      | 明确表示**未赋值、无数据**                | 明确表示**有数据，但为空字符串**         |



> 第二个问题：
>
> 问的是C#的GC回收机制，G0，G1，G2啥的。
>
> C# 的 **垃圾回收机制（GC，Garbage Collection）** 是 .NET CLR 中非常核心的一部分，它采用的是一种 **分代（Generational）垃圾回收算法**。你说的“三个块”，其实就是：
>
> ------
>
> ## ✅ C# 的 GC 有三个“代”：
>
> 分别称为：
>
> | 代名        | 英文名       | 说明                                         |
> | ----------- | ------------ | -------------------------------------------- |
> | **第 0 代** | Generation 0 | 存放**新创建**的对象，生命周期短，回收频率高 |
> | **第 1 代** | Generation 1 | 中间代：用于存活时间比 Gen 0 稍长的对象      |
> | **第 2 代** | Generation 2 | 存活时间长的对象，会被晋升到这里，回收最慢   |
>
> 
>
> ------
>
> ### 🔁 GC 的基本工作流程：
>
> 1. **对象刚创建时** → 进入 **Gen 0**；
> 2. GC 执行时，先清理 **Gen 0** 中“无法访问”的对象；
> 3. **Gen 0 中存活的对象**（还被引用的）→ 晋升到 **Gen 1**；
> 4. **Gen 1 的对象如果再次存活** → 晋升到 **Gen 2**；
> 5. **Gen 2** 被称为“老年代”，只有内存压力很大或显式调用 `GC.Collect()` 才会被回收。
>
> ------
>
> ### 📌 为什么要分三代？
>
> - **大多数对象生命周期很短**（比如局部变量、临时字符串）；
> - 所以频繁清理整个堆开销太大；
> - 把对象按“寿命”分组，**先清理短命的那一批**，效率更高。
>
> ------
>
> ### 📚 内部结构（堆）简图如下：
>
> ```
> text复制编辑┌───────────────┬───────────────┬───────────────┐
> │  Generation 0 │  Generation 1 │  Generation 2 │
> │（新生代）     │（中生代）     │（老年代）     │
> └───────────────┴───────────────┴───────────────┘
> ```
>
> - 每一代都位于托管堆（Managed Heap）中；
> - Gen 2 又可以扩展到 **Large Object Heap（LOH）**（大对象堆）。
>
> ------
>
> ## 🧱 扩展：Large Object Heap（LOH）
>
> - 如果你创建了超过 **85,000 字节**的大对象（比如大数组、大字节缓冲区），它不会放在 Gen 0~2，而是直接放进 **LOH**；
> - LOH **不分代**，回收代价更大，**只在 Gen 2 GC 时才清理**；
> - .NET Core 3.0+ 支持 LOH 的压缩（以前会造成严重碎片）。
>
> ------
>
> ## 🔧 开发者视角需要知道什么？
>
> - 不需要手动释放对象（除非非托管资源）；
> - 避免频繁创建大对象；
> - 避免长期持有对短生命周期对象的引用（会阻止它们被回收）；
> - 可以用 `GC.Collect()` 触发手动 GC，但一般不推荐（除非你非常了解代的行为）；
> - 可以用 `WeakReference` 管理临时可缓存对象；
> - `.NET Core / .NET 5+` 中 GC 更加智能，默认行为已经非常高效。
>
> 
>
> 问题还问了：为什么不建议手动GC.Collect()？
>
> .NET 的垃圾回收器是一个 **高智能、代分层、延迟触发、按需回收的系统**，会破坏GC 的“自适应优化”机制，性能代价极高，可能导致卡顿



> `Dispose()` 和析构函数（Finalizer）有什么区别？
>
> ## 一句话区别：
>
> > `Dispose()` 是 **手动释放资源的方法**，
> >  析构函数（`~ClassName()`）是 **由 GC 自动调用的资源清理器**。
> >
> > 先由 GC 发现对象不可达，标记回收 → 然后（如果对象有析构函数）调用 `~析构函数` → 然后下一轮 GC 真正回收对象的内存。

> 第三位 头发很少，遇到真大佬了。。。
>
> 他就是问些 线上测试题的问题，包括复杂度，控件定义以及算法。。。我真不太会。
>
> 哎，结果就是没戏了。
>
> 外企喜欢问点稀奇古怪的问题。。
>
> 他问了，卷心菜里面长得快还是外面长得快。
>
> 还有9宫格描点的问题。